#pragma once
#include <FastLED.h>
#include <math.h>

#define ws2812b_SendRGB FastLED.show

#if defined(ARDUINO) && ARDUINO >= 100
	#include "arduino.h"
#else
	#include "WProgram.h"
#endif

// Set num_leds as the maximum length of all the strips in the set.
constexpr int num_leds = 48;

// A double staff has functionally two LED strips attached to it. In reality, there are four, but they're bound in pairs.
CRGB leds_1[num_leds];
CRGB leds_2[num_leds];

namespace conv
{
    inline CHSV from_hs_16(uint16_t C)
    {
        switch (C)
        {
            case 0: return {0, 0, 0};
            case 1: return {0, 0, 60};
            default:
                uint8_t H = C >> 8;
                uint8_t S = C & 0xff;

                return { H, S, 60 };
        }
    }

    inline CHSV from_hs_8(uint8_t C)
    {
        if		(C == 254) return { 0, 0, 0 };
        else if (C == 255) return { 0, 0, 255 };

        uint8_t H = (C / 3) * 3;
        uint8_t S = C % 3 * 255;

        return { H, S, 255 };
    }

    inline CHSV from_hue_8(uint8_t H) { return { H, 255, 255 }; }

    inline void hsv2rgb(CHSV & hsv, CRGB & rgb){

        constexpr float sixth = 255.0f/6.0f;
        float H = hsv.h;
        const uint8_t sixths = H / sixth;
    
        float s = hsv.s / 255.0f;
        float v = hsv.v / 255.0f;
        float C = s * v;
        float X = C * (1 - abs(fmod(H/sixth, 2) - 1));
        float m = v - C;
        float r, g, b;

        switch (sixths){
            case 0: 
                r = C, g = X, b = 0;
                break;
            case 1: 
                r = X, g = C, b = 0;
                break;
            case 2: 
                r = 0, g = C, b = X;
                break;
            case 3: 
                r = 0, g = X, b = C;
                break;
            case 4: 
                r = X, g = 0, b = C;
                break;
            default: 
                r = C, g = 0, b = X;
                break;

        }

    rgb.r = (r + m) * 255;
    rgb.g = (g + m) * 255;
    rgb.b = (b + m) * 255;
}

}

template <typename T>
struct entry
{
	const char * key;
	const T * value;
};

struct entry_info
{
	const char * key;
	const uint16_t rows;
	const uint16_t cols;
    const uint8_t  mode;
};

constexpr uint16_t default_16[num_leds] {};
constexpr uint8_t  default_8 [num_leds] {};

// Default image array, displays when the requested image cannot be found. 
// Currently black, another suggested solution is to put some color there.
template < typename T > 
const T * default_ptr() {}

template <>
const uint8_t * default_ptr() { return default_8; }

template <>
const uint16_t * default_ptr() { return default_16; }

/**
 * @brief Compares two c-strings at compile time. !*x == !*y returns true in case
 *        of two nullptrs, so essentially it checks whether the length is the same.
 *        Checks the letters via recursive instantiation, by each letter.
 */
constexpr bool same(const char * x, const char * y)
{
	// Found at : https://stackoverflow.com/questions/8026906/constexpr-and-initialization
	
	return !*x && !*y ? true : (*x == *y && same(x + 1, y + 1));
}


/**
 * @brief Searches for the right entry in a C array at compile-time. Checks each entry via recursive instantiation, 
 * time load is irrelevant as long as there aren't too many images (which there will not be).
 * 
 * @tparam T: color pixel data type (i.e. the type of the image arrays generated by the preprocessor executable). 
 *            uint16_t (mode hs_16) and uint8_t (modes hs_8 and hue_8) allowed.   
 * @param name: c-style string, containing the image name. Requires full filename, e.g. "image.png". If the name isn't found,
 *              returns a black image (check default_ptr) for safety reasons. 
 * @param map:  pointer to the array of image entries, a "map", where the key is the filename of the image and 
 *              the value is the pointer to the generated image array. 
 * @param length: the number of images left before the map ends (reverse counter). 
 * @return constexpr const T* (pointer to the requested image array or default_ptr).
 */
template < typename T >
constexpr const T * value(const char * name, const entry < T > * map, const uint8_t length)
{
	// Found at : https://stackoverflow.com/questions/8026906/constexpr-and-initialization

	return (length == 0) ? default_ptr < T >() : same(map->key, name) ? map->value : value(name, map + 1, length - 1);
}

// Similarly to the first function, rows, cols and mode return the defaults for a black image if not found, and return
// image specs otherwise.

constexpr const uint16_t rows(const char * name, const entry_info * const map, const uint8_t length)
{
	return (length == 0) ? 1 : (same(map->key, name) ? map->rows : rows(name, map + 1, length - 1));
}

constexpr const uint16_t cols(const char * name, const entry_info * const map, const uint8_t length)
{
	return (length == 0) ? num_leds : same(map->key, name) ? map->cols : cols(name, map + 1, length - 1);
}

constexpr const uint8_t mode(const char * name, const entry_info * const map, const uint8_t length)
{
	return (length == 0) ? 0 : same(map->key, name) ? map->mode : mode(name, map + 1, length - 1);
}


/**
 * @brief Awaits the end of the requested display time. Operates in milliseconds.
 * 
 * @param t_beg: display start point.
 * @param wait: requested display time. 
 */
void waitfor(uint32_t t_beg, uint32_t wait)
{
    uint32_t t_end = millis();
    while (t_end < t_beg + wait) {
        t_end = millis();
    }
}

/**
 * @brief Awaits the end of the requested display time. Operates in microseconds.
 * 
 * @param t_beg: display start point.
 * @param wait: requested display time. 
 */
void waitfor_micros(uint32_t t_beg, uint32_t wait)
{   
    uint32_t t_end = micros();
    while (t_end < t_beg + wait) {
        t_end = micros();
    }
}

/**
 * @brief Decodes the colors and updates the LED strips.
 * 
 * @tparam Func: type of the function that decodes the array.
 * @tparam T: color pixel data type (i.e. the type of the image arrays generated by the preprocessor executable). 
 *            uint16_t (mode hs_16) and uint8_t (modes hs_8 and hue_8) allowed.   
 * @param begin: pointer to the beginning of the row displayed. 
 * @param end:   pointer to the end of the row displayed. 
 * @param func_arg: the function that decodes the array, as in
 *               conv:: from_hs_16 for 0,
 *               conv:: from_hs_8 for 1,
 *               conv:: from_hue_8 for 2.
 * @param t_beg_mcs: the starting time of the function, in microseconds. 
 * @param wait_mcs:  row display time in microseconds.
 */
template <typename Func, typename T>
void show_row(const T * const begin, const T * const end, const Func func_arg, uint32_t t_beg_mcs, uint32_t wait_mcs)
{   
    CHSV hsv;
    CRGB rgb;

    for (auto it = begin; it < end; ++it)
    {
        hsv = func_arg(*it);
        hsv2rgb_spectrum(hsv, rgb);
        
        leds_1[it - begin] = rgb;
        leds_2[it - begin] = rgb;
    }
    FastLED.show();
    systick_uptime_millis++; 
    
    /*

    FastLED.show() causes an interrupt, which doesn't allow the timer to tick. On average, one second of time is lost
    on each interrupt, and so we reincrement the system counter. Tested on 300 seconds, the error achieved with this method is
    100 ms per 5 minutes or 300 seconds at num_leds = 48. It has been discovered that the incrementation is required at 
    num_leds >= 47 (considering there are two strips, likely that means 94), at some point you ned to reincrement again 
    but that has not been thoroughly tested.

    */

    waitfor_micros(t_beg_mcs, wait_mcs);
}

/**
 * @brief Processes the pixel array sequentially, sends instructions to show_row,
 *        which communicates directly with the LED strip.  
 * 
 * @tparam T: color pixel data type (i.e. the type of the image arrays generated by the preprocessor executable). 
 *            uint16_t (mode hs_16) and uint8_t (modes hs_8 and hue_8) allowed.  
 * @param image: pointer to the array containing pixels, each row in the array is the column shown by the LED strip at a given moment 
 * @param rows: row count (column count in relation to the real image) 
 * @param cols: column count (row count in relation to real image) 
 * @param mode: encoding mode. 0 is hs_16, 1 is hs_8, 2 is hue_8. 
 * @param freq: the number of columns of the image displayed per second. As of 07.08.2022, the highest achievable limit is 280.  
 * @param wait_ms: image display time in milliseconds. 
 */
template < typename T >
void communicator(const T * const image, 
        const uint16_t rows, const uint16_t cols, const uint8_t mode, const uint16_t freq, const uint32_t wait_ms)
{   
    // To understand how this reflects on the real image, replace each 'row' with 'column'. 
    // The image displayed on the strip is functionally turned 90 degrees clockwise by the preprocessor.

    const uint32_t begin_mcs = micros();

    const uint32_t row_count = freq * (wait_ms / 1000.0);
    const uint32_t row_time = wait_ms * 1000 / row_count; // in microseconds  

    uint32_t cur_row, t_beg_row;

    for (auto i = 0U; i < row_count; ++i)
    {
        cur_row = i % rows;
        
        switch (mode)
            {
            case 0:
                show_row(image + cols * cur_row, 
                    image + cols * (cur_row + 1), conv::from_hs_16, begin_mcs + i * row_time, row_time); 
                break;
            case 1:
                show_row(image + cols * cur_row, 
                    image + cols * (cur_row + 1), conv::from_hs_8,  begin_mcs + i * row_time, row_time); 
                break;
            case 2:
                show_row(image + cols * cur_row, 
                    image + cols * (cur_row + 1), conv::from_hue_8, begin_mcs + i * row_time, row_time); 
            }
    }

    waitfor_micros(begin_mcs, wait_ms*1000);
}


/**
 * @brief Searches for the required image, as well as its dimensions and encoding type in image_map at compile_time,
 *        passes the pointer and the integers to the communicator.
 * 
 * @tparam T: color pixel data type (i.e. the type of the image arrays generated by the preprocessor executable). 
 *            uint16_t (mode hs_16) and uint8_t (modes hs_8 and hue_8) allowed. 
 * @param name: c-style string, containing the image name. Requires full filename, e.g. "image.png". If the name isn't found,
 *              returns a black image for safety reasons.
 * @param image_map:  pointer to the array of image entries, a "map", where the key is the filename of the image and 
 *                    the value is the pointer to the generated image array. 
 * @param image_info: pointer to the array of image information entries, containing the name as the 'key' and
 *                    numbers of rows (height), columns (width), as well as the mode of encoding.
 * @param freq: the number of columns of the image displayed per second. As of 07.08.2022, the highest achievable limit is 280. 
 * @param image_count: the constant depicting the number of images encoded, i.e. the size of image_map and image_info. 
 * @param wait_ms: image display time in milliseconds. 
 */
template < typename T >
void image(const char * name, 
           const entry< T > * image_map, const entry_info * image_info, 
           const uint32_t freq, const uint8_t image_count, const uint32_t wait_ms)
{
    auto image = value < T > (name, image_map,  image_count);
    auto r     = rows        (name, image_info, image_count);
    auto c     = cols        (name, image_info, image_count);
    auto m     = mode        (name, image_info, image_count);

    communicator(image, r, c, m, freq, wait_ms);
}

/**
 * @brief Image Processor class. Made for simplicity's sake, so that one doesn't have to carry array pointers over 
 *        into every function call. To use, call the 'show' member function. 
 * 
 * @tparam T: color pixel data type (i.e. the type of the image arrays generated by the preprocessor executable). 
 *            uint16_t (mode hs_16) and uint8_t (modes hs_8 and hue_8) allowed. 
 *            If you need both options, simply creating two class instances SHOULD work, but has not been tested yet.
 * @param image_map: pointer to the array of image entries, a "map", where the key is the filename of the image and 
 *                   the value is the pointer to the generated image array.
 * @param image_info: pointer to the array of image information entries, containing the name as the 'key' and
 *                    numbers of rows (height), columns (width), as well as the mode of encoding. As the image is turned 90 degrees
 *                    clockwise, height and width are in reverse in relation to the real image.
 * @param image_count: the constant depicting the number of images encoded, i.e. the size of image_map and image_info.
 */
template < typename T >
class ImageProcessor
{
public:
    /**
     * @brief Construct a new Image Processor object
     * 
     * @param im: pointer to the array of image entries, a "map", where the key is the filename of the image and 
     *            the value is the pointer to the generated image array. 
     * @param ii: pointer to the array of image information entries, containing the name as the 'key' and
     *            numbers of rows (height), columns (width), as well as the mode of encoding. 
     * @param ic: the constant depicting the number of images encoded, i.e. the size of image_map and image_info. 
     */
    ImageProcessor(const entry < T > * im, const entry_info  * ii, const uint8_t ic) :
            image_map(im), image_info(ii), image_count(ic) {}

    /**
     * @brief The interface function of the image processing module.
     * 
     * @param name: c-style string, containing the image name. Requires full filename, e.g. "image.png". If the name isn't found,
     *              returns a black image for safety reasons. 
     * @param freq: the number of columns of the image displayed per second. As of 07.08.2022, the highest achievable limit is 280.  
     * @param wait_ms: image display time in milliseconds.   
     */
    void show(const char * name, const uint32_t freq, const uint32_t wait_ms){
        image(name, image_map, image_info, freq, image_count, wait_ms);
    }

private:
    const entry < T > * image_map;
    const entry_info  * image_info;
    const uint8_t image_count;
};